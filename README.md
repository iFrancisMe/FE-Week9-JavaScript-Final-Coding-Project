
# WAR, The Card Game

**Francis Mendoza**  
**Promineo Tech Bootcamp**  
**Frontend Programming - FESD20231128**  
**Week 9 JavaScript - Unit Final Project**  

This project is an implementation of a simplified version of the WAR card game, in which, the game runs without any user action, but simulates 2 players playing against each other using a simplified set of rules.

This program is my Week 9 JavaScript final project submission for the Frontend programming bootcamp course at Promineo Tech.

Project requirements:

- Deal 26 Cards to each Player from a Deck of 52 cards.
- Iterate through the turns where each Player plays a Card.
- The Player who played the higher card is awarded a point.
- Ties result in zero points for both Players.
- After all cards have been played, display the score and declare the winner.

## JavaScript Topics Covered: (From Curriculum)

- Data Types
- JavaScript Principals
- Object Oriented Programming
- Unit Testing with Mocha and Chai
- Using GitHub 

## Additional Topics Explored for This Project

- Randomization
- Fisher-Yates Algorithm
- Dynamic Method Handling
- Easter Eggs
## Authors

- [@Francis Mendoza](https://github.com/iFrancisMe)


## About This Project  <sub>_(skip ahead for details on running the program)_</sub>

While still figuring out how I wanted to implement the game operation's visual design, the game's title, "WAR," reminded me of an old movie, "WarGames (1983)," in which what was taken to be a harmless computer game, would have led to global disaster. While I do not remember the details of the movie or even if I watched it, one of the most memorable moments of the movie is a seemingly simple question given by the protagonist computer terminal, "Shall we play a game?"

Considering this game's similar name, which reminded me of the movie, I decided to include that infamous question to introduce my project to whomever happens to run my program. On the same subject of nostalgia, I was inspired to recreate the type of console-based interaction presented in the movie where the interactions progressed prompt by prompt. Being that this game is automated and does not take in human interaction, I have implemented a facsimile of a prompted interaction by delaying the console output and sending all messages intended for the console instead to a class method which asynchronously delays all incoming messages by a factor according to the order they come in, implemented by way of a message counter or queue. Otherwise, all the gameplay output is dumped relatively immediately on the screen, making it difficult to follow the progress of the gameplay.

Another inspiration I had, came from contemplating on how I was going to implement a shuffling procedure for the card deck. I needed a quick approach that would give me some kind of shuffled deck. Since we had recently covered sorting arrays in the course material, I figured I would simply sort the array of card objects, but how would I sort the array out of order? I proceeded then to take a naive approach and recreated the array of card objects into a 2-dimensioanl array, with each row consisting of an array with the card object at index 0 and a random number generated at index 1. Now I could simply sort the array according to the column of random numbers generated by the Math.random() function.

In class, however, our instructor briefly brought up an algorithm that could potentially prove to be most useful for shuffling my array of card objects, the Fisher-Yates shuffle (no, it's not a dance), which I do seem to recall while attending university. Anyway, after a quick trip to Wikipedia to see what the fuss was all about, I got the jist of how the shuffle is accomplished while maintaining a time complexity of O(n), which means that the shuffling could be accomplished within a single pass of the array, thereby keeping linear time as opposed to iterating through the array over multiple passes, resulting in an exponential time complexity. For example, on my original method, I iterate through the array of card objects 3 times to get to the final outcome; once to add a random column, once to sort the random column, and a final one to remove the column of random numbers. So, for the given array, with 3 passes my original method achieved a time complexity of O(n<sup>3</sup>). We covered time complexity of algorithms at university too, but it started to go over my head half-way into that course. Interestingly, I feel like I have a better grasp after being away from it for some time and looking back to it now. Anyway, the Fisher-Yates shuffle seemed to be way better than my original method, so I added it into this program as a shuffle method option.

Having different options to shuffle the deck got me thinking, however. I did not want to have to rewrite my class and methods to accommodate a new method every time I needed a new sorting implementation. So, I was inspired to write into the class constructor a way to dynamically call on the intended sorting/shuffling method given as a parameter. There are probably better ways to do this, but I opted for an array of methods within the class itself filtered by the name of the method given, returning a reference to the actual method. Since doing this, I have added additional sorting methods as required by the game's design as it evolved, and this dynamic approach made it simple to add additional sorting methods without much risk in breaking operation for the other existing ones since I avoided having to add and update conditionals or switch logic.

Once I got the game itself coded, I thought sitting through 26 rounds of artificial player interactions might seem a bit dry after a while. However, since I was already vested in the randomization of collections, I thought I could liven up the gameplay console output with some humorously canned responses. So, I added a method that included an array of short praises and remarks to utter randomly after each round declaring one of the players as the winner of the round. I followed this up by adding another collection of responses to give at the end of the game when the game winner is announced. However, some of the responses I came up with turned out resembling what one might read on a T-shirt relaying or parodying some words of wisdom, idiom, or catchphrase. So, I created a final collection of pseudo lessons for displaying at the end of program.

While implementing these pseudo fortune-cookie remarks, I remembered how old cartoon programming would end with some lesson or moral. Since I was already adding bits of nostalgia to this game with the throwback to "WarGames," I thought back to Animaniacs, the 90's cartoon that used to have a parodical implementation of these episodic "morals." This inspired me to quote the whimsically canned comedic sequence shown just before sharing the lesson to be learned at the end of each episode.

Finally, for the end of the game, I wanted a caption to indicate that the program was at its end. Since I was already on the nostalgic theme bandwagon, I thought, what better quote is there than from a kindred spirit of sorts? The somewhat not too long-ago released movie, Ready Player One (2018), included a scene with what seemed like a most appropriate closing farewell for this program.

A side note:
I realize one might not want to sit through a non-interactive game for 26 rounds while not being able to play. So, I added the ability to disable the delayed handling of console messages by providing an option of passing a Boolean false value into the class constructor for the game. Details are commented in the source code, and I may also add some additional documentation for running this program in the GitHub README.md.
## Documentation

## *tl;dr*

#### Step 1.
Clone the repository  

#### Step 2.
#### To run in **Boring mode**, or **Non-Interactive** mode: (where the program does not emulate interactive behavior)

- Open the "index.js" file in an editor and scroll to the bottom. 

- At these lines:  

        // Do not change this. 
        const numberOfPlayers = 2; 

        let game = new WarCardGame(numberOfPlayers, true); // Boolean true = "Interactive" mode. False = Output gameplay to console at normal speed without delay

        game.letsPlayAGame('fisherYates');  // Game starts with short throwback sequence

        //game.startGame('fisherYates');  // Game starts immediately without special gift

- Change the **true** to **false** in the class parameter and save the changes.
*Note: You could try different shuffling algorithms by passing the name of one of the following methods as a parameter.* **Example:** ***game.letsPlayAGame('random');***    

        'random', 'fisherYates', 'orderByHighest', 'orderByLowest'
    
                    Don't forget to save changes :)

#### To run in *Fun mode*, skip to *Step 3*
*Note:* ***refer to note above***

#### Step 3.
Open **index.html** in a browser. You will need to ***right-click*** on the page and ***click*** **Inspect** and ***click*** on **Console**, or just make life easier and press the following keyboard shortcut for your browser:  
##### *****Option + ⌘ + C***** for ***Safari*** ****(MacOS)****  
##### *****Option + ⌘ + J***** for ***Chrome-based browsers*** ****(MacOS)****
##### *****Ctrl + Shift + J***** for ***Chrome-based browsers*** ****(Windows, Linux)****

### *Running the program (The longer version)*
The default running mode of this program is designed to resemble an interactive console program where there is some time in between console output and console input. Since there is no input, the program would otherwise iterate through the game turns seemingly all at once and appear to display everything immediately after executing the script. To mimic console interaction, there is a delay at every console output to resemble prompting for player input as each "player" interacts with the game and "plays" a card. The only side effect to this is that reaching the end of the program will take roughly half a minute to go through 26 "interactive" turns. However, rounds ending in a tie do skip this delay and proceed to the next round.

#### To run this game without any output delay (i.e., boring mode), clone this repository and open the index.js file. Navigate to the bottom of the file and you will see the following 2 lines:  

    // Do not change this. 
    const numberOfPlayers = 2; 

    let game = new WarCardGame(numberOfPlayers, true); // Boolean true = "Interactive" mode. False = Output gameplay to console at normal speed without delay

    game.letsPlayAGame('fisherYates');  // Game starts with short throwback sequence

    //game.startGame('fisherYates');  // Game starts immediately without special gift

Change the Boolean value in the parameter portion of the first line above to false. This will cause the program to display all output in real time.
You can also, optionally, comment the 'letsPlayAGame' method and uncomment the 'startGame' method to skip the throwback sequence mentioned in the ***About*** section of this document. 

#### To run the game without modification, simply run the program's index.html file in a browser after cloning this repository and enjoy some included Easter eggs. You will need to open the console. Refer to the tl;dr section above if needed.
*Note: You could try different shuffling algorithms by passing the name of one of the following methods as a parameter.*  **Example:** ***game.letsPlayAGame('random');***   
    
    'random', 'fisherYates', 'orderByHighest', 'orderByLowest'
    
                   Don't forget to save changes :)

>Thank you for playing my game - James Halliday/Anorak (Ready Player One, 2018)

# Supplemental Information
The project requirements, based on the simplified game rules design, calls for 2 players, so this program is ultimately designed and tested for 2 non-interactive players. However, I have designed most, if not all, of this program's classes and methods to potentially allow for additional players or optionally, different playing cards or decks, or, at least, some thought and effort went into not constraining their functionality strictly to the project's requirements so that it might be more easily adaptable into handling more players, other game implementations, or possibly even human interaction.


